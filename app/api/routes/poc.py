from fastapi import APIRouter, HTTPException, Depends
from typing import Dict, List, Optional, Any
from pydantic import BaseModel
from app.ai.services.poc_generator import POCGenerator
from app.core.security import get_auth_dependency, get_admin_dependency
from app.dependencies import get_model_manager, get_prompt_manager

router = APIRouter()

class POCRequest(BaseModel):
    """Request model for PoC generation."""
    cve_id: str
    description: Optional[str] = "Security vulnerability"
    vulnerability_type: Optional[str] = "unknown"
    affected_component: Optional[str] = "system"
    model_name: Optional[str] = "codellama:7b"

class POCResponse(BaseModel):
    """Response model for PoC generation."""
    cve_id: str
    code: str
    documentation: Dict[str, str]
    metadata: Dict[str, Any]

@router.post("/generate", response_model=POCResponse)
async def generate_poc(
    request: POCRequest,
    auth: str = Depends(get_auth_dependency()),
    model_manager = Depends(get_model_manager),
    prompt_manager = Depends(get_prompt_manager)
) -> POCResponse:
    """Generate a PoC for a CVE using AI."""
    try:
        # Initialize the POC generator with AI services
        poc_generator = POCGenerator(model_manager, prompt_manager)
        
        # Generate the PoC using AI
        poc_info = await poc_generator.generate_poc(
            cve_id=request.cve_id,
            description=request.description,
            vulnerability_type=request.vulnerability_type,
            affected_component=request.affected_component,
            model_name=request.model_name
        )
        
        return POCResponse(
            cve_id=poc_info["cve_id"],
            code=poc_info["code"],
            documentation=poc_info["documentation"],
            metadata=poc_info["metadata"]
        )
        
    except Exception as e:
        # If AI generation fails, provide a fallback response
        fallback_code = f"""#!/usr/bin/env python3
\"\"\"
Proof of Concept for {request.cve_id}
Generated by CVE Analysis Platform

WARNING: This is a template PoC. The AI service is currently unavailable.
Please customize this code based on the specific vulnerability details.

CVE ID: {request.cve_id}
Vulnerability Type: {request.vulnerability_type}
Affected Component: {request.affected_component}
Description: {request.description}
\"\"\"

import requests
import sys
import argparse
from urllib.parse import urljoin

class CVEExploit:
    def __init__(self, target_url):
        self.target_url = target_url
        self.session = requests.Session()
        
    def check_vulnerability(self):
        \"\"\"
        Check if the target is vulnerable to {request.cve_id}
        \"\"\"
        try:
            # TODO: Implement specific vulnerability check for {request.vulnerability_type}
            response = self.session.get(self.target_url, timeout=10)
            
            # Add specific checks based on vulnerability type
            if response.status_code == 200:
                print(f"[+] Target is reachable: {{self.target_url}}")
                return True
            else:
                print(f"[-] Target unreachable: {{response.status_code}}")
                return False
                
        except Exception as e:
            print(f"[!] Error checking vulnerability: {{e}}")
            return False
    
    def exploit(self):
        \"\"\"
        Attempt to exploit the vulnerability
        \"\"\"
        try:
            # TODO: Implement specific exploit for {request.vulnerability_type}
            print(f"[*] Attempting to exploit {request.cve_id}")
            print(f"[*] Target: {{self.target_url}}")
            print(f"[*] Vulnerability Type: {request.vulnerability_type}")
            print(f"[*] Affected Component: {request.affected_component}")
            
            # Placeholder exploit logic
            print("[!] This is a template PoC - implement specific exploit logic")
            return False
            
        except Exception as e:
            print(f"[!] Exploit failed: {{e}}")
            return False

def main():
    parser = argparse.ArgumentParser(description=f"PoC for {request.cve_id}")
    parser.add_argument("target", help="Target URL")
    parser.add_argument("--check", action="store_true", help="Only check vulnerability")
    
    args = parser.parse_args()
    
    exploit = CVEExploit(args.target)
    
    if args.check:
        if exploit.check_vulnerability():
            print("[+] Target appears vulnerable")
        else:
            print("[-] Target does not appear vulnerable")
    else:
        if exploit.check_vulnerability():
            exploit.exploit()
        else:
            print("[-] Target is not vulnerable")

if __name__ == "__main__":
    main()
"""
        
        return POCResponse(
            cve_id=request.cve_id,
            code=fallback_code,
            documentation={
                "description": f"Template PoC for {request.cve_id} (AI service unavailable)",
                "vulnerability_type": request.vulnerability_type,
                "affected_component": request.affected_component,
                "usage": f"python3 poc.py <target_url> [--check]",
                "warnings": "This is a template PoC. Customize based on specific vulnerability details.",
                "requirements": "requests",
                "note": "AI service was unavailable - this is a fallback template"
            },
            metadata={
                "generated_at": "2024-01-01T00:00:00Z",
                "model_used": "fallback_template",
                "version": "1.0",
                "ai_available": False,
                "error": str(e)
            }
        )

@router.get("/{cve_id}", response_model=POCResponse)
async def get_poc(
    cve_id: str,
    auth: str = Depends(get_auth_dependency())
) -> POCResponse:
    """Get a previously generated PoC."""
    # Mock response for existing PoC
    return POCResponse(
        cve_id=cve_id,
        code=f"# Existing PoC for {cve_id}\nprint('This PoC was previously generated')",
        documentation={
            "description": f"Previously generated PoC for {cve_id}",
            "usage": "Run this code in a controlled environment",
            "warnings": "This is for testing purposes only"
        },
        metadata={
            "generated_at": "2024-01-01T00:00:00Z",
            "model_used": "codellama",
            "version": "1.0"
        }
    )

@router.get("/", response_model=List[str])
async def list_pocs(
    auth: str = Depends(get_auth_dependency())
) -> List[str]:
    """List all available PoCs."""
    return ["CVE-2024-1234", "CVE-2024-5678", "CVE-2024-9999"]

@router.post("/{cve_id}/validate")
async def validate_poc(
    cve_id: str,
    auth: str = Depends(get_auth_dependency())
) -> Dict[str, Any]:
    """Validate a generated PoC."""
    return {
        "cve_id": cve_id,
        "validation_status": "passed",
        "checks": {
            "syntax_valid": True,
            "dependencies_available": True,
            "security_warnings": False
        },
        "validated_at": "2024-01-01T00:00:00Z"
    } 